/**
 * Starts Zalenium in a Selenium grid and executes the given body. When the body finishes, the Zalenium container will
 * gracefully shutdown and archive all videos generated by the tests.
 *
 * @param config contains a map of settings that change the Zalenium behavior. Can be a partial map or even left out.
 *      The defaults are:
 *      [seleniumVersion   : '3.141.59-p8',
 *      seleniumImage      : 'elgalu/selenium',
 *      zaleniumVersion    : '3.141.59g',
 *      zaleniumImage      : 'dosel/zalenium',
 *      zaleniumVideoDir   : 'zalenium',
 *      sendGoogleAnalytics: false,
 *      debugZalenium      : false]
 * @param seleniumNetwork The Zalenium container will be added to this docker network. This is useful if other containers
 *      must communicate with Zalenium while being in a docker network. If empty or left out, Zalenium will stay in the
 *      default network.
 * @param closure the body
 */
void call(Map config = [:], String seleniumNetwork, Closure closure) {

    def defaultConfig = [
            seleniumImage     : 'elgalu/selenium',
            seleniumVersion   : "3.141.59-p8",
            workerImageTag    : "3.141.59-zinc",
            firefoxWorkerCount: 0,
            chromeWorkerCount : 0,
            debugSelenium     : false,
            seleniumPictureDir: "selenium"
    ]

    // Merge default config with the one passed as parameter
    config = defaultConfig << config
    if (config.firefoxWorkerCount == 0 && config.chromeWorkerCount == 0) {
        throw new ConfigurationException("Cannot start selenium test. Please configure at least one workerCount for the desired browser.")
    }

    checkSeleniumVersionCompatibility(config.seleniumVersion, config.workerImageTag)

    sh "mkdir -p ${config.zaleniumVideoDir}"

    // explicitly pull the image into the registry. The documentation is not fully clear but it seems that pull()
    // will persist the image in the registry better than an docker.image(...).runWith()
    def seleniumImage = docker.image("${config.seleniumImage}:${config.seleniumVersion}")
    seleniumImage.pull()

    def uid = findUid()
    def gid = findGid()

    networkParameter = ""
    if (seleniumNetwork != null && !seleniumNetwork.isEmpty()) {
        networkParameter = "--network ${seleniumNetwork}"
    }
    //todo create picture folder

    gridDebugParameter = ""
    if (gridDebugParameter != null && !gridDebugParameter.isEmpty()) {
        gridDebugParameter = "-e GRID_DEBUG=true"
    }

    String hubName = generateZaleniumJobName() + "-seleniumhub"

    seleniumImage.withRun(
            // Run with Jenkins user, so the files created in the workspace by zalenium can be deleted later
            // Otherwise that would be root, and you know how hard it is to get rid of root-owned files.
            "-u ${uid}:${gid} " +
                    "${networkParameter} " +
                    "${gridDebugParameter} " +
                    "--name ${hubName}"
    ) { hubContainer ->
        String seleniumIp = findContainerIp(hubContainer)

        def firefoxContainers = startFirefoxWorker(hubName, config.workerImageTag, config.firefoxWorkerCount)
        def chromeContainers = startChromeWorker(hubName, config.workerImageTag, config.chromeWorkerCount)

        try {
            waitForSeleniumToGetReady(seleniumIp)

            closure.call(hubContainer, seleniumIp, uid, gid)
        } finally {
            stopSeleniumSession(hubContainer.id, firefoxContainers, chromeContainers)
        }
    }
}

private void checkSeleniumVersionCompatibility(String seleniumVersion, String workerImageTag) {
    def workerSeleniumVersion = seleniumVersion.split("-")[0]
    def hubSeleniumVersion = workerImageTag.split("-")[0]

    if (workerSeleniumVersion != hubSeleniumVersion) {
        def warning = sprintf("The selected Selenium hub version '%s' differs from the worker version '%s'. " +
                "You should consider the same version for both to avoid compatibility issues during the test.",
                hubSeleniumVersion, seleniumVersion)
        unstable(warning)
    }
}

String findContainerIp(container) {
    sh(returnStdout: true,
            script: "docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' ${container.id}")
            .trim()
}

String findUid() {
    sh(returnStdout: true,
            script: 'id -u')
            .trim()
}

String findGid() {
    sh(returnStdout: true,
            script: 'id -g')
            .trim()
}

void waitForSeleniumToGetReady(String host) {
    timeout(time: 1, unit: 'MINUTES') {
        echo "Waiting for selenium to become ready at http://${host}"
        while (!isSeleniumReady(host)) {
            sleep(time: 1, unit: 'SECONDS')
        }
        echo "Selenium ready at http://${host}"
    }
}

boolean isSeleniumReady(String host) {
    sh(returnStdout: true,
            script: "curl -sSL http://${host}:4444/wd/hub/status || true") // Don't fail
            .contains('ready\": true')
}

void waitForSeleniumSessionsToEnd(String host) {
    timeout(time: 5, unit: 'MINUTES') {
        echo "Waiting for selenium sessions to end at http://${host}"
        while (isSeleniumSessionsActive(host)) {
            sleep(time: 10, unit: 'SECONDS')
        }
        echo "No more selenium sessions active at http://${host}"
    }
}

boolean isSeleniumSessionsActive(String host) {
    sh(returnStatus: true,
            script: "(curl -sSL http://${host}:4444/grid/api/sessions || true) | grep sessions") == 0
}

class ConfigurationException extends RuntimeException {
    ConfigurationException(String message) {
        super(message)
    }
}

private Collection<String> startFirefoxWorker(String hubHost, String workerImageTag, int count) {
    def workerNodeImage = "selenium/node-firefox:${workerImageTag}"

    return runWorkerNodes(workerNodeImage, hubHost, count)
}

private Collection<String> startChromeWorker(String hubHost, String workerImageTag, int count) {
    def workerNodeImage = "selenium/node-chrome:${workerImageTag}"

    return runWorkerNodes(workerNodeImage, hubHost, count)
}

private Collection<String> runWorkerNodes(GString workerNodeImage, String hubHost, int count) {
    echo "Starting worker node with docker image ${workerNodeImage}"

    def workerImage = docker.image(workerNodeImage)
    workerImage.pull()
    dockerDefaultArgs = "-d --net grid -e HUB_HOST=${hubHost} -v /dev/shm:/dev/shm selenium/node-chrome"

    for (int i = 0; i < count; i++) {
        container = workerImage.run()
        list.add(container.id)
    }
    return list
}

void stopSeleniumSession(String seleniumHubID, Collection<String> firefoxIDs, Collection<String> chromeIDs) {
    //TODO RICHTIGMACHEN firefoxIDs.toArray()

    echo "Stopping Firefox containers..."
    stopAndLogContainers(firefoxIDs)

    echo "Stopping Chrome containers..."
    stopAndLogContainers(chromeIDs)

    // Stop container gracefully and wait
    sh "docker stop ${seleniumHubID}"
    // Store log for debugging purposes
    sh "docker logs ${seleniumHubID} > selenium-docker.log 2>&1"

    echo "Remove containers..."
    removeContainers(firefoxIDs)
    removeContainers(chromeIDs)
    sh "docker rm -f ${seleniumHubID}"
}

private void stopAndLogContainers(Collection<String> containerIDs) {
    for (String containerId : containerIDs) {
        echo "Stopping container with ID ${containerId}"
        sh "docker stop ${containerId}"

        echo "Container with ID ${containerId} produced these logs:"
        sh "docker logs ${containerId} > selenium-docker.log 2>&1"
    }
}